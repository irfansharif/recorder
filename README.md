recorder
---

[![Go Reference](https://pkg.go.dev/badge/github.com/irfansharif/recorder.svg)](https://pkg.go.dev/github.com/irfansharif/recorder)

Recorder is a handy little library that lets you record a set of operations and
then replay these recordings, which provides a handy way to mock out the
recorded components. Operations are defined only by a "command" and an
"output", see [grammar](#grammar) below. This approach has a few ergonomic
advantages:
- Mocked data is easily auto-generated by simply capturing "the real thing"
- Recordings are human readable, making it easy to git-diff behavioural changes
- There's little need to thread in of mock interfaces throughout the codebase

This library is similar in spirit to
[cockroachdb/copyist](https://github.com/cockroachdb/copyist). For real world
usage, see [cockroachdb/dev](https://github.com/cockroachdb/dev)
where it's used to mock out all attempts to shell out (`exec.Command`) and
also intercepts all OS operations (`os.{Mkdir,Remove,Symlink}`).

---

Users will typically want to embed a recorder into a component that oversees
any sort of side-effect or I/O they'd like to capture and later playback from
(instead of "doing the real thing" in tests).

These side-effects can be arbitrary. If we're building a CLI that calls into
the filesystem to filter for a set of directories and writes out a zip file,
the I/O could be the globbing for files, and side-effects could include
creating the zip file.

I/O could also capture calling into anything that sits outside some
module boundary. The recorder, if embedded into the module, let's us:
- Record the set of outbound calls, and the relevant responses, while
"doing the real thing"
- Play back from an earlier recording, intercepting all outbound calls and
effectively mocking out all dependencies the component has.

# Example

Let us try and mock out the globber component from earlier. Broadly what it
could look like is:

```go
type globber struct {
   *recorder.Recorder
}

func (g *globber) glob(pattern string) (matches []string) {
   if g.Recorder == nil || g.Recording() {
       // Do the real thing.
       matches, _ = filepath.Glob(pattern)
   }

   if g.Recording() {
       g.record(pattern, matches)
       return matches
   }

   return g.replay(pattern)
}
```

We'll want to define tiny "parsers" to convert our module-specific input/output
to the string representation recorder understand.

```go
func (g *globber) record(pattern string, matches []string) {
   op := recorder.Operation{
       Command: pattern,
       Output:  fmt.Sprintf("%s\n", strings.Join(matches, "\n")),
   }
   g.Record(op)
}

func (g *globber) replay(pattern string) (matches []string) {
   found, _ := g.Next(func(op recorder.Operation) error {
       if op.Command != pattern {
       } // expected op.Command, got pattern
       output := strings.TrimSpace(op.Output)
       matches = strings.Split(output, "\n")
       return nil
   })
   if !found {
   } // recording for pattern not found
   return matches
}
```

Strung together we could construct tests that would plumb in recorders with the
right mode. Say if the test is run using `-record`, it would emit recording
files:

```
    go test -run TestGlobber -record
```

If the flag is unspecified, recorders would be configured to playback from
earlier recordings.

```
    go test -run TestGlobber
```

With our globber, a recording file could have the following contents:

```
testdata/files/*
----
testdata/files/aaa
testdata/files/aab
testdata/files/aac
```

When playing back from it, we wouldn't actually need to reach into the
file-system. The results from an earlier run were already recorded; we'd just
use that instead. See `example/` for this exact testing pattern.

---

Once the recordings are captured, they can be edited and maintained by hand.
An example of where we might want to do this is for recordings for commands
that generate copious amounts of output. It suffices for us to trim the
recording down by hand, and make sure we don't re-record over it (by inspecting
the diffs during review).  Recordings, like other mocks, are also expected to
get checked in as test data fixtures.

# Grammar

The printed form of an operation (the base unit of what can be recorded) is
defined by the following grammar. This is what's used when generating/reading
from recording files.

    # comment
    <command> \
    <command wraps over onto the next line>
    ----
    <output>

By default `<output>` cannot contain blank lines. This alternative syntax
allows for it:

    <command>
    ----
    ----
    <output>

    <more output>
    ----
    ----

The syntax here was borrowed from
[cockroachdb/datadriven](https://github.com/cockroachdb/datadriven).
